

VkResult mvk_init_sampler(vk_render_state *p_vkrs, VkSampler &sampler)
{
  VkResult res;

  VkSamplerCreateInfo samplerCreateInfo = {};
  samplerCreateInfo.sType = VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO;
  samplerCreateInfo.magFilter = VK_FILTER_NEAREST;
  samplerCreateInfo.minFilter = VK_FILTER_NEAREST;
  samplerCreateInfo.mipmapMode = VK_SAMPLER_MIPMAP_MODE_NEAREST;
  samplerCreateInfo.addressModeU = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  samplerCreateInfo.addressModeV = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  samplerCreateInfo.addressModeW = VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE;
  samplerCreateInfo.mipLodBias = 0.0;
  samplerCreateInfo.anisotropyEnable = VK_FALSE;
  samplerCreateInfo.maxAnisotropy = 1;
  samplerCreateInfo.compareOp = VK_COMPARE_OP_NEVER;
  samplerCreateInfo.minLod = 0.0;
  samplerCreateInfo.maxLod = 0.0;
  samplerCreateInfo.compareEnable = VK_FALSE;
  samplerCreateInfo.borderColor = VK_BORDER_COLOR_FLOAT_OPAQUE_WHITE;

  /* create sampler */
  res = vkCreateSampler(p_vkrs->device, &samplerCreateInfo, NULL, &sampler);
  assert(res == VK_SUCCESS);
  return res;
}

VkResult mvk_init_buffer(vk_render_state *p_vkrs, texture_object &texObj)
{
  VkResult res;
  bool pass;

  VkBufferCreateInfo buffer_create_info = {};
  buffer_create_info.sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO;
  buffer_create_info.pNext = NULL;
  buffer_create_info.flags = 0;
  buffer_create_info.size = texObj.tex_width * texObj.tex_height * 4;
  buffer_create_info.usage = VK_BUFFER_USAGE_TRANSFER_SRC_BIT;
  buffer_create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
  buffer_create_info.queueFamilyIndexCount = 0;
  buffer_create_info.pQueueFamilyIndices = NULL;
  res = vkCreateBuffer(p_vkrs->device, &buffer_create_info, NULL, &texObj.buffer);
  assert(res == VK_SUCCESS);

  VkMemoryAllocateInfo mem_alloc = {};
  mem_alloc.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  mem_alloc.pNext = NULL;
  mem_alloc.allocationSize = 0;
  mem_alloc.memoryTypeIndex = 0;

  VkMemoryRequirements mem_reqs;
  vkGetBufferMemoryRequirements(p_vkrs->device, texObj.buffer, &mem_reqs);
  mem_alloc.allocationSize = mem_reqs.size;
  texObj.buffer_size = mem_reqs.size;

  VkFlags requirements = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
  pass = memory_type_from_properties(info, mem_reqs.memoryTypeBits, requirements, &mem_alloc.memoryTypeIndex);
  assert(pass && "No mappable, coherent memory");

  /* allocate memory */
  res = vkAllocateMemory(p_vkrs->device, &mem_alloc, NULL, &(texObj.buffer_memory));
  assert(res == VK_SUCCESS);

  /* bind memory */
  res = vkBindBufferMemory(p_vkrs->device, texObj.buffer, texObj.buffer_memory, 0);
  assert(res == VK_SUCCESS);
  return res;
}

VkResult mvk_init_image(vk_render_state *p_vkrs, texture_object &texObj, const char *textureName, VkImageUsageFlags extraUsages,
                VkFormatFeatureFlags extraFeatures)
{
  VkResult U_ASSERT_ONLY res;
  bool U_ASSERT_ONLY pass;
  std::string filename = get_base_data_dir();

  if (textureName == nullptr)
    filename.append("lunarg.ppm");
  else
    filename.append(textureName);

  if (!read_ppm(filename.c_str(), texObj.tex_width, texObj.tex_height, 0, NULL))
  {
    std::cout << "Try relative path\n";
    filename = "../../API-Samples/data/";
    if (textureName == nullptr)
      filename.append("lunarg.ppm");
    else
      filename.append(textureName);
    if (!read_ppm(filename.c_str(), texObj.tex_width, texObj.tex_height, 0, NULL))
    {
      std::cout << "Could not read texture file " << filename;
      exit(-1);
    }
  }

  VkFormatProperties formatProps;
  vkGetPhysicalDeviceFormatProperties(p_vkrs->gpus[0], VK_FORMAT_R8G8B8A8_UNORM, &formatProps);

  /* See if we can use a linear tiled image for a texture, if not, we will
     * need a staging buffer for the texture data */
  VkFormatFeatureFlags allFeatures = (VK_FORMAT_FEATURE_SAMPLED_IMAGE_BIT | extraFeatures);
  texObj.needs_staging = ((formatProps.linearTilingFeatures & allFeatures) != allFeatures);

  if (texObj.needs_staging)
  {
    assert((formatProps.optimalTilingFeatures & allFeatures) == allFeatures);
    init_buffer(info, texObj);
    extraUsages |= VK_IMAGE_USAGE_TRANSFER_DST_BIT;
  }
  else
  {
    texObj.buffer = VK_NULL_HANDLE;
    texObj.buffer_memory = VK_NULL_HANDLE;
  }

  VkImageCreateInfo image_create_info = {};
  image_create_info.sType = VK_STRUCTURE_TYPE_IMAGE_CREATE_INFO;
  image_create_info.pNext = NULL;
  image_create_info.imageType = VK_IMAGE_TYPE_2D;
  image_create_info.format = VK_FORMAT_R8G8B8A8_UNORM;
  image_create_info.extent.width = texObj.tex_width;
  image_create_info.extent.height = texObj.tex_height;
  image_create_info.extent.depth = 1;
  image_create_info.mipLevels = 1;
  image_create_info.arrayLayers = 1;
  image_create_info.samples = NUM_SAMPLES;
  image_create_info.tiling = texObj.needs_staging ? VK_IMAGE_TILING_OPTIMAL : VK_IMAGE_TILING_LINEAR;
  image_create_info.initialLayout = texObj.needs_staging ? VK_IMAGE_LAYOUT_UNDEFINED : VK_IMAGE_LAYOUT_PREINITIALIZED;
  image_create_info.usage = (VK_IMAGE_USAGE_SAMPLED_BIT | extraUsages);
  image_create_info.queueFamilyIndexCount = 0;
  image_create_info.pQueueFamilyIndices = NULL;
  image_create_info.sharingMode = VK_SHARING_MODE_EXCLUSIVE;
  image_create_info.flags = 0;

  VkMemoryAllocateInfo mem_alloc = {};
  mem_alloc.sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO;
  mem_alloc.pNext = NULL;
  mem_alloc.allocationSize = 0;
  mem_alloc.memoryTypeIndex = 0;

  VkMemoryRequirements mem_reqs;

  res = vkCreateImage(p_vkrs->device, &image_create_info, NULL, &texObj.image);
  assert(res == VK_SUCCESS);

  vkGetImageMemoryRequirements(p_vkrs->device, texObj.image, &mem_reqs);

  mem_alloc.allocationSize = mem_reqs.size;

  VkFlags requirements = texObj.needs_staging ? 0 : (VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT);
  pass = memory_type_from_properties(info, mem_reqs.memoryTypeBits, requirements, &mem_alloc.memoryTypeIndex);
  assert(pass);

  /* allocate memory */
  res = vkAllocateMemory(p_vkrs->device, &mem_alloc, NULL, &(texObj.image_memory));
  assert(res == VK_SUCCESS);

  /* bind memory */
  res = vkBindImageMemory(p_vkrs->device, texObj.image, texObj.image_memory, 0);
  assert(res == VK_SUCCESS);

  res = vkEndCommandBuffer(p_vkrs->cmd);
  assert(res == VK_SUCCESS);
  const VkCommandBuffer cmd_bufs[] = {info.cmd};
  VkFenceCreateInfo fenceInfo;
  VkFence cmdFence;
  fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
  fenceInfo.pNext = NULL;
  fenceInfo.flags = 0;
  vkCreateFence(p_vkrs->device, &fenceInfo, NULL, &cmdFence);

  VkSubmitInfo submit_info[1] = {};
  submit_info[0].pNext = NULL;
  submit_info[0].sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  submit_info[0].waitSemaphoreCount = 0;
  submit_info[0].pWaitSemaphores = NULL;
  submit_info[0].pWaitDstStageMask = NULL;
  submit_info[0].commandBufferCount = 1;
  submit_info[0].pCommandBuffers = cmd_bufs;
  submit_info[0].signalSemaphoreCount = 0;
  submit_info[0].pSignalSemaphores = NULL;

  /* Queue the command buffer for execution */
  res = vkQueueSubmit(p_vkrs->graphics_queue, 1, submit_info, cmdFence);
  assert(res == VK_SUCCESS);

  VkImageSubresource subres = {};
  subres.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  subres.mipLevel = 0;
  subres.arrayLayer = 0;

  VkSubresourceLayout layout = {};
  void *data;
  if (!texObj.needs_staging)
  {
    /* Get the subresource layout so we know what the row pitch is */
    vkGetImageSubresourceLayout(p_vkrs->device, texObj.image, &subres, &layout);
  }

  /* Make sure command buffer is finished before mapping */
  do
  {
    res = vkWaitForFences(p_vkrs->device, 1, &cmdFence, VK_TRUE, FENCE_TIMEOUT);
  } while (res == VK_TIMEOUT);
  assert(res == VK_SUCCESS);

  vkDestroyFence(p_vkrs->device, cmdFence, NULL);

  if (texObj.needs_staging)
  {
    res = vkMapMemory(p_vkrs->device, texObj.buffer_memory, 0, texObj.buffer_size, 0, &data);
  }
  else
  {
    res = vkMapMemory(p_vkrs->device, texObj.image_memory, 0, mem_reqs.size, 0, &data);
  }
  assert(res == VK_SUCCESS);

  /* Read the ppm file into the mappable image's memory */
  if (!read_ppm(filename.c_str(), texObj.tex_width, texObj.tex_height,
                texObj.needs_staging ? (texObj.tex_width * 4) : layout.rowPitch, (unsigned char *)data))
  {
    std::cout << "Could not load texture file lunarg.ppm\n";
    exit(-1);
  }

  vkUnmapMemory(p_vkrs->device, texObj.needs_staging ? texObj.buffer_memory : texObj.image_memory);

  VkCommandBufferBeginInfo cmd_buf_info = {};
  cmd_buf_info.sType = VK_STRUCTURE_TYPE_COMMAND_BUFFER_BEGIN_INFO;
  cmd_buf_info.pNext = NULL;
  cmd_buf_info.flags = 0;
  cmd_buf_info.pInheritanceInfo = NULL;

  res = vkResetCommandBuffer(p_vkrs->cmd, 0);
  res = vkBeginCommandBuffer(p_vkrs->cmd, &cmd_buf_info);
  assert(res == VK_SUCCESS);

  if (!texObj.needs_staging)
  {
    /* If we can use the linear tiled image as a texture, just do it */
    texObj.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    set_image_layout(info, texObj.image, VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_LAYOUT_PREINITIALIZED, texObj.imageLayout,
                     VK_PIPELINE_STAGE_HOST_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT);
  }
  else
  {
    /* Since we're going to blit to the texture image, set its layout to
         * DESTINATION_OPTIMAL */
    set_image_layout(info, texObj.image, VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_LAYOUT_UNDEFINED,
                     VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, VK_PIPELINE_STAGE_TOP_OF_PIPE_BIT, VK_PIPELINE_STAGE_TRANSFER_BIT);

    VkBufferImageCopy copy_region;
    copy_region.bufferOffset = 0;
    copy_region.bufferRowLength = texObj.tex_width;
    copy_region.bufferImageHeight = texObj.tex_height;
    copy_region.imageSubresource.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
    copy_region.imageSubresource.mipLevel = 0;
    copy_region.imageSubresource.baseArrayLayer = 0;
    copy_region.imageSubresource.layerCount = 1;
    copy_region.imageOffset.x = 0;
    copy_region.imageOffset.y = 0;
    copy_region.imageOffset.z = 0;
    copy_region.imageExtent.width = texObj.tex_width;
    copy_region.imageExtent.height = texObj.tex_height;
    copy_region.imageExtent.depth = 1;

    /* Put the copy command into the command buffer */
    vkCmdCopyBufferToImage(p_vkrs->cmd, texObj.buffer, texObj.image, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, 1, &copy_region);

    /* Set the layout for the texture image from DESTINATION_OPTIMAL to
         * SHADER_READ_ONLY */
    texObj.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
    set_image_layout(info, texObj.image, VK_IMAGE_ASPECT_COLOR_BIT, VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL, texObj.imageLayout,
                     VK_PIPELINE_STAGE_TRANSFER_BIT, VK_PIPELINE_STAGE_FRAGMENT_SHADER_BIT);
  }

  VkImageViewCreateInfo view_info = {};
  view_info.sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO;
  view_info.pNext = NULL;
  view_info.image = VK_NULL_HANDLE;
  view_info.viewType = VK_IMAGE_VIEW_TYPE_2D;
  view_info.format = VK_FORMAT_R8G8B8A8_UNORM;
  view_info.components.r = VK_COMPONENT_SWIZZLE_R;
  view_info.components.g = VK_COMPONENT_SWIZZLE_G;
  view_info.components.b = VK_COMPONENT_SWIZZLE_B;
  view_info.components.a = VK_COMPONENT_SWIZZLE_A;
  view_info.subresourceRange.aspectMask = VK_IMAGE_ASPECT_COLOR_BIT;
  view_info.subresourceRange.baseMipLevel = 0;
  view_info.subresourceRange.levelCount = 1;
  view_info.subresourceRange.baseArrayLayer = 0;
  view_info.subresourceRange.layerCount = 1;

  /* create image view */
  view_info.image = texObj.image;
  res = vkCreateImageView(p_vkrs->device, &view_info, NULL, &texObj.view);
  assert(res == VK_SUCCESS);
  return res;
}

void mvk_init_texture(vk_render_state *p_vkrs, const char *textureName, VkImageUsageFlags extraUsages,
                  VkFormatFeatureFlags extraFeatures)
{
  struct texture_object texObj;

  /* create image */
  init_image(info, texObj, textureName, extraUsages, extraFeatures);

  /* create sampler */
  init_sampler(info, texObj.sampler);

  p_vkrs->textures.push_back(texObj);

  /* track a description of the texture */
  p_vkrs->texture_data.image_info.imageView = p_vkrs->textures.back().view;
  p_vkrs->texture_data.image_info.sampler = p_vkrs->textures.back().sampler;
  p_vkrs->texture_data.image_info.imageLayout = VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL;
}


























VkResult mvk_init_fence(vk_render_state *p_vkrs, VkFence &fence)
{
  VkFenceCreateInfo fenceInfo;
  fenceInfo.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
  fenceInfo.pNext = NULL;
  fenceInfo.flags = 0;
  return vkCreateFence(p_vkrs->device, &fenceInfo, NULL, &fence);
}

void mvk_init_submit_info(vk_render_state *p_vkrs, VkSubmitInfo &submit_info, VkPipelineStageFlags &pipe_stage_flags)
{
  submit_info.pNext = NULL;
  submit_info.sType = VK_STRUCTURE_TYPE_SUBMIT_INFO;
  submit_info.waitSemaphoreCount = 1;
  submit_info.pWaitSemaphores = &info.imageAcquiredSemaphore;
  submit_info.pWaitDstStageMask = &pipe_stage_flags;
  submit_info.commandBufferCount = 1;
  submit_info.pCommandBuffers = &info.cmd;
  submit_info.signalSemaphoreCount = 0;
  submit_info.pSignalSemaphores = NULL;
}

void mvk_init_present_info(vk_render_state *p_vkrs, VkPresentInfoKHR &present)
{
  present.sType = VK_STRUCTURE_TYPE_PRESENT_INFO_KHR;
  present.pNext = NULL;
  present.swapchainCount = 1;
  present.pSwapchains = &info.swap_chain;
  present.pImageIndices = &info.current_buffer;
  present.pWaitSemaphores = NULL;
  present.waitSemaphoreCount = 0;
  present.pResults = NULL;
}

void mvk_init_clear_color_and_depth(vk_render_state *p_vkrs, VkClearValue *clear_values)
{
  clear_values[0].color.float32[0] = 0.2f;
  clear_values[0].color.float32[1] = 0.2f;
  clear_values[0].color.float32[2] = 0.2f;
  clear_values[0].color.float32[3] = 0.2f;
  clear_values[1].depthStencil.depth = 1.0f;
  clear_values[1].depthStencil.stencil = 0;
}

void mvk_init_render_pass_begin_info(vk_render_state *p_vkrs, VkRenderPassBeginInfo &rp_begin)
{
  rp_begin.sType = VK_STRUCTURE_TYPE_RENDER_PASS_BEGIN_INFO;
  rp_begin.pNext = NULL;
  rp_begin.renderPass = p_vkrs->render_pass;
  rp_begin.framebuffer = p_vkrs->framebuffers[info.current_buffer];
  rp_begin.renderArea.offset.x = 0;
  rp_begin.renderArea.offset.y = 0;
  rp_begin.renderArea.extent.width = p_vkrs->width;
  rp_begin.renderArea.extent.height = p_vkrs->height;
  rp_begin.clearValueCount = 0;
  rp_begin.pClearValues = nullptr;
}

