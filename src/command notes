



corePrintLine
Midge midge
midge.print

global.field = Obsequence()

maccess(field, &0, global)
maccess(other, &1)
assignm(&0,&1)



Cpx c = a.get()
  indent()
    invoke(get, a)
  initI(Cpx, c)
  
  int a = 3+4+5
  indent()
    indent()
      mathAdd(0, 4, 5)
    mathAddI(0, 3)
  assignnewI(int, a)

midge->child->printer->print
  indent()
    indent()
      invoke(child,midge)
    invokeI(printer)
  invokeI(print)

bool flag = false;
print(flag)

if(flag)
print("flag was true")
else
binvoke

addClassAttribute(Node,Node*,parent);
a->part->num = b->num
{
ref1(part,a)
ref1(num,$1)
ref2(num,b)
assign($1,$2)
}


:>conditional


errorCodes
branching
conditional on instance member
pointers
type memory and method memory (statics/consts)
create bound types


:>initializePointer(dataType,pointerName)
    ~ <Cpx *> c;
	~ Smart Pointers (instanced value deleted with 0 pointers left)
:>initializeDefault(dataType,instanceName,scope=LocalBlock)
    ~ Cpx c;
:>initalize(dataType,instanceName,valueInstanceName,scope=LocalBlock)
    ~ int c = a
:>operation(instanceName,op,left=null,right=null)
	~ c++
	~ a = 2 * 4
:>if(left,comparator=null,right=null)
	> followed by [singleStatement OR block]
	> followed by *else [condition OR block]...
:>arraySet(arrayInstanceName,index,value)
:>arrayResize(items,amount)
:>assign(instanceName,valueInstanceNameOrLiteralValue)
    ~ c = a
:>assign(instanceName,valueMemberName,valueInstanceName)
	~ c = b.a
:>print(text)
:>invoke(resultInstanceName,memberName,valueInstanceName,[args]...)
:>mathAdd(instanceName,valueInstanceName)
    ~ The others... subtract,etc.
:>createClass(className)
:>createAttribute(className,attributeName,type)
:>addClassMethod(className,methodName,returnType,[argType,argName]...)
:>addClassMethodCode(className,methodName,{code})
:>addClassSuperClass(className,superClassName)
:>bindingInvoke()
    ~ bindingInvoke(methodName,argsIdentifierOrLiteral...)
#####################################################
#####################################################
#####################################################
#####################################################



mvproto

from main : do a corelangfile load and process each command

// Create function
cmd 1: takes two ints, adds them together and returns
cmd 2: creates a func
  creates one local variab. passes two to func 1
  stores the result in another local variab and prints that
cmd 3: registers func 2 to main:init 
  
this func calls 
prints out 3 + 6



#####################################################













Representation Encoder
FileData->Interpreter->Representation

Representation Persistence
Representation->FileData

Representation to Source Decoder
Representation->Source

#####################################################

Representation:
 - This is what can be modified during runtime.
 
Type:AppEntry
  Constants:
    int BUILD_NUMBER
  Function:
    CoreLangInterpreter interpreter = CoreLangInterpreter
    if(interpreter.interpret_core()) {
      return 0;
    }

    return 0;

Type:Class
  name:DNode
  enum:Kind
    Abstract
    Visual
    Function
    Event
    Attribute
  fields:
    public DNode *parent
    public vector<DNode *> children;
    public Kind kind;
  methods:
    public get_kind()
      return kind;

Type:Class
  name:AbstractNode
  inherits:DNode

Type:Class
  name:VisualNode
  inherits:AbstractNode

Type:Class
  name:FunctionNode
  inherits:DNode

Type:Class
  name:EventNode
  inherits:DNode

Type:Class
  name:AttributeNode
  inherits:DNode

Type:Class
  name:CoreLangInterpreter
  method:void interpret_core()
    


#####################################################
#####################################################
#####################################################
#####################################################
		
        
        
Main:

Type:ApplicationEntry
--Constants:
----int BUILD_NUMBER 0
--Entry:
----string file_name = "main.cpp"
----vector<string> includes, namespace, constants, entry;
----%read_text_lines: command_file "mcmd.txt" tp
------%switch_indent_text 2
--------"Includes:" includes
----------@first includes.push_back("\n");
----------includes.push_back("\n");
----------includes.push_back(tp);
--------"UseNamespaceStd" namespace
----------namespace.push_back("\n\nusing namespace std");
--------"Constants" constants
----------@first constants.push_back("\n");
----------constants.push_back("\n");
----------int a = str.find(' ');
----------int b = str.find(' ', a + 1);
----------constants.push_back("const " + str.substr(0, b) + " = " + str.substr(b + 1) + ";");
--------"Entry" entry
----------
------
------
------
------
------}
------
------
------
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        
        // Create the Structures required to create {down} (with c++ & restart)

		// Create the Structures required to create CommandInterface (with custom-lang)
		init_code.push_back("Global::create_abstract ProcessManager");
		init_code.push_back(
			"node/create_function Function add_function String p_name"
			"{"
			"  func_node = Function $p_name"
			"  add_child func_node"
			"  return func_node"
			"}"
			);
		init_code.push_back(
			"global/create_function Event add_event Node p_parent String p_name"
			"{"
			"  event_node = Event $p_name"
			"  p_parent.add_child event_node"
			"  return event_node"
			"}"
			);
		init_code.push_back("fish");
		init_code.push_back("fish");
		init_code.push_back("fish");
		init_code.push_back("fish");
		init_code.push_back("fish");

		// Create CommandInterface to respond to pre-coded commands (with custom-lang)
		base_cmd_interface.push_back("global/create_visual null CommandInterface");
		base_cmd_interface.push_back("set_property global/CommandInterface left_anchor 1");
		base_cmd_interface.push_back("set_property global/CommandInterface left_margin -200");
		base_cmd_interface.push_back("set_property global/CommandInterface top_anchor 1");
		base_cmd_interface.push_back("set_property global/CommandInterface top_margin -40");
		base_cmd_interface.push_back("set_property global/CommandInterface right_anchor 1");
		base_cmd_interface.push_back("set_property global/CommandInterface right_margin 0");
		base_cmd_interface.push_back("set_property global/CommandInterface bottom_anchor 1");
		base_cmd_interface.push_back("set_property global/CommandInterface bottom_margin 0");
		base_cmd_interface.push_back("add event command submitted");
		base_cmd_interface.push_back("add function command submitted callback");
		base_cmd_interface.push_back("fish");
		base_cmd_interface.push_back("fish");
		base_cmd_interface.push_back("fish");
		base_cmd_interface.push_back("end function");

		// Extend CommandInterface to be user editable (with user commands)
		commands.push_back("edit CommandInterface");
		commands.push_back("add visual text frame");
		commands.push_back("set left margin 4");
		commands.push_back("set top margin 4");
		commands.push_back("set right margin 4");
		commands.push_back("set bottom margin 4");
		commands.push_back("add text command input text box");
		commands.push_back("add function key input callback");
		commands.push_back("add argument uint key");
		commands.push_back("switch on key");
		commands.push_back("default");
		commands.push_back("set string c invoke global key to char with key");
		commands.push_back("set text invoke get text");
		commands.push_back("invoke set text with text plus c");
		commands.push_back("case enter");
		commands.push_back("set text invoke get text");
		commands.push_back("invoke clear");
		commands.push_back("emit signal command submitted with text");
		commands.push_back("end function");
		commands.push_back("connect key input callback to global key input");
